# 액션, 계산, 데이터

- 함수형 프로그래머는 코드를 액션, 계산, 데이터로 분류한다.
- 액션: 호출 시점 또는 횟수에 의존하는 코드, (부수효과를 일으키는 코드)
- 계산: 호출 시점과 횟수에 의존하지 않는 코드. 외부 세상에 어떠한 영향도 미치지 않는 코드.
  동일한 인자를 넣었을 때 동일한 결과를 리턴하는 함수. (순수 함수)
- 데이터: 이벤트에 대해 기록한 사실.

# 액션

- 함수형 프로그래머는 액션에서 계산과 데이터를 발라낸다.
  - 액션과 결합하면, 결합된 함수도 액션이 되버린다.
  - 테스트 하기가 어렵다. (시점이나 순서에 의존하기 때문에)
- 가능한 액션을 적게 사용한다.

# 액션에서 계산 추출하기

- 액션과 계산을 분리한다. 그리고 액션 코드를 최소화하기 위해서 응집도를 높인다.
- 액션에서 계산을 추출하여 계산의 재사용성을 높인다. (마케팅팀도 사용할 수 있도록.)
- 암묵적 입력과 암묵적 출력을 없앤다. (암묵적 입력과 암묵적 출력은 부수효과를 발생시킨다.)
  - 암묵적 입력은 함수의 인자로 받음으로써 해결한다.
  - 암묵적 출력은 복사본을 반환하여 원본 데이터에 영향을 미치지 않도록 한다. (부수효과가 없다.)

# 더 좋은 액션 만들기.

- 비즈니스 요구 사항과 설계를 일치시킨다.
  - `gets_free_shipping` 함수 예시.
- 액션에서도 암묵적 입력과 암묵적 출력을 최대한 줄이면 좋다.
  - 강한 결합으로 이루어져있기 때문. 명시적인 입력과 출력은 느슨하게 결합.  
    강한 결합으로 인해 재사용성이 떨어지고, 코드를 변경하기 어려워진다.
  - 암묵적 입력과 출력이 많을수록 테스트하기 어려움.
- 설계는 엉켜있는 코드를 푸는 것이다.
  - 함수로 분리하여 추상화 수준을 높이고, 쉽게 조합할 수 있도록 한다.
  - 도메인을 포함한 함수를, 작게 분리하여 도메인을 모르는 함수로 만들기. (유틸리티 함수로 만들어버리기)
  - 함수 입장에서 알아야 하는 것을 최소화 시키기.
  - 함수가 클 때, 함수의 역할을 분류하여 작은 함수로 나눈다.

# 불변성 유지하기.

- 읽기와 쓰기를 분리하기.
- 쓰기는 불변성을 유지하도록 카피 온 라이트 작업을 하여 읽기로 바꾸기.  
   (불변 데이터를 만들고, 수정하는 것은 읽기이다. 기존 데이터를 변경하지 않으므로.)
- 쓰기를 하면서 읽기도 하는 동작을 함수로 분리하기.
  - pop, shift와 같은 메소드는 쓰기와 읽기를 동시에 수행.
  - 불변성을 지키도록 새로운 배열을 만들어서 수정을 진행하고, 객체 형태로 리턴한다면 기존 메소드의 역할을 그대로 수행할 수 있다.
- 왜 불변하게 유지하는 것이 중요할까?
  - 불변 데이터를 읽는 것은 계산이다.
  - 쓰기를 읽기로 바꾸는 것은 액션의 수를 줄여준다.
- 불변성을 유지하는데 성능이 많이 드는 것이 아닙니까?
  - 구조적 공유를 하는 부분이 있기 때문에, 중첩된 모든 객체를 복사하는 것은 아니다. 즉 참조값만을 새롭게 만들기 때문에 성능상 큰 문제가 없다.
  - 가비지 콜렉터를 매우 빠르다.

# 레거시 코드 환경에서 불변성 지키기.

- 데이터를 변화시키는 레거시 코드에서 불변성을 지키는 방법은 방어적 복사를 하는 것이다.
- 방어적 복사는 안전 지대에서 불안전 지대로 데이터를 넘길 때 깊은 복사를 수행하고, 불안전 지대에서 안전 지대로 데이터를 넘길 때도 깊은 복사를 수행한다.
  - 안전 지대에서 불안전 지대로 넘길 때 깊은 복사를 하는 이유는, 불안전 지대에서 데이터를 변경할 수 있기 떄문이다.
  - 불안전 지대에서 안전 지대로 넘길 때 깊은 복사를 하는 이유는, 불안전 지대에서 해당 데이터에 대한 참조값을 가지고 있기 떄문에 변경 가능성이 있기 때문이다.
- 래퍼 함수를 만들어서 사용하는 것이 좋다. 클라이언트 코드에서 방어적 복사의 2가지 과정 중 1개를 누락시킬 수 있기 때문이다.
- 안전 지대에서 방어적 복사를 할 필요는 없다. 방어적 복사는 깊은 복사를 수행하기 때문에 성능이 카피 온 라이트보다 좋지 않다.

# 계층형 설계

- 각 계층에 있는 함수는 바로 아래 계층에 있는 함수를 사용해 정의한다.

# 직접 구현

- 바로 아래 계층에 있는 함수를 이용하여 함수를 정의할 때, 만일 아래 계층에 있는 함수가 존재하지 않는다면 아래 계층에 있는 함수를 정의해준다.  
  그리고 만들려고 하는 함수는 바로 아래 계층에 있는 함수만을 사용해 정의한다.
- 같은 계층에 있는지 확인하기 위한 방법 중 하나로, 호출 그래프를 이용하여 시각화하면 쉽게 알아볼 수 있다. 전체적인 시스템 계층도 쉽게 알아볼 수 있다.
- 같은 계층에 있는 함수는 같은 목적을 가져야 한다. 그리고 추상화 수준이 다르기에, 아래 계층에서 신경쓰는 구체적인 내용은 신경쓰지 않아도 좋다.
  - 장바구니를 다루는 계층에서는, 장바구니가 배열 형태인지, 객체 형태인지 알 필요가 없어야한다.
  - 코드가 같은 추상화 수준에 있어야 읽기가 쉽다.
- 직접 구현 패턴을 적용하는 방법 중 하나는, 함수가 더 구체적인 내용을 다루지 않도록 함수를 일반적인 함수로 추출하는 것.

# 추상화 벽

- 어떤 계층은 중요한 세부 구현을 감추고, 인터페이스를 제공한다. 인터페이스를 활용하면 고수준의 추상화 단계만 생각하면 된다. (어떤 것을 신경쓰지 않아도 좋지?)
- 팀 간 책임을 명확하게 나눈다.
  - 마케팅 팀은 장바구니의 구체적인 구현을 알 필요없이, 추상화 벽에서 제공하는 인터페이스를 조합하여 함수를 작성한다.
  - 추상화 벽에 존재하는 함수들이 변경이 일어나더라도, 마케팅 팀의 코드는 변경할 필요가 없다.
  - 라이브러리나, API와 유사하다. (JS는 기계 언어에 대한 추상화 벽을 제공.)
- 언제 사용하면 좋을까?

  - 구현을 쉽게 바꾸기 위해 (객체 지향의 캡슐화랑 유사한듯.)
  - 코드 가독성 향상
  - 팀 간 조율 줄일 수 있음. (마케팅팀은 장바구니에 관한 로직을 신경쓰지 않고 코드를 작성할 수 있음.)

# 작은 인터페이스

- 인터페이스를 최소화 해야함.
- 추상화 벽에 코드가 많으면 구현이 변경될 경우 고쳐야 할 코드가 많아짐.
- 추상화 벽에 인터페이스가 많으면, 알아야 할 것이 많아짐. 딱 필요한 함수만을 가지고 있어야함.

# 편리한 계층

- 지금 편리한가? 편리하다면 다른 계층과 섞이도록 그대로 둔다. 하지만, 만일 구체적인 것을 너무 많이 알아야 하거나 코드가 지저분해진다면 다시 패턴을 적용해라.
- 코드가 속한 추상화 계층은 작업할 때 편리해야한다. 역설적으로 패턴에 너무 매몰되면 안된다는 뜻이다.

# 호출 그래프로 알 수 있는 정보

- 가장 많이 고쳐야하는 비즈니스 로직과 관련된 코드는 그래프 상단에 위치해야한다.
- 그래프 하단에 위치하는 함수일수록 테스트가 중요해진다. (자주 변경되지 않고, 재사용성이 높기 때문에.)
- 낮은 수준의 단계로 함수를 추출하면 재사용성이 높아진다.
