# 함수 본문을 콜백으로 바꾸기

- 코드를 고차 함수로 만드는 강력한 방법.
- 함수 이름에 있는 암묵적 인자가 보일 때 수행하면 좋다. (비슷한 역할을 하는 함수들이 많을 때.)
- 고차 함수의 좋은 점은 코드를 추상화 할 수 있다는 점이다. 특정한 케이스마다 다르게 동작하는 경우를 매번 새로운 함수를 정의하는게 아닌, 함수를 인자로 받아서 대신 수행한다.
- JS의 배열의 map, forEach, filter 메소드의 경우, 수동 루프를 추상화한 고차함수이다.
- `withLogging` 함수는 전형적인 고차함수의 예시라고 볼 수 있다. 이러한 사고를 하려고 노력해야한다.
- 또한 함수를 인자로 받는 것의 장점은, 평가 시점을 뒤로 미룰 수 있다는 것이며 선택적으로 호출되거나, 어떠한 문맥에서 호출될 수도 있다. (try-catch문 내에서 등)

# 일급인 것과 아닌 것.

- 일급이 아닌 것을 일급으로 바꾸는 능력은 함수형 프로그래머에게 중요한 덕목이다.
- 예시로 + 연산은 일급이 아니다. 하지만 `(a,b) => a+b`라는 함수는 일급이다. 이처럼 일급이 아닌 것을 일급으로 만들어서 활용한다.

# 추상화 벽

- 어떤 객체를 변경시키는 함수가 중복되어, 객체의 필드명과 value를 받아서 할당해주는 함수가 있다고 가정해보자. 이 함수는 추상화 벽 원칙을 위반하는 것인가?
  - 그렇지 않다. 세부 구현은 노출되지 않았기 때문이다. 또한 필드명은 일급으로, 언어의 모든 기능을 활용해서 처리해줄 수 있다. (필드명이 바뀌면 내부적으로는 변경시켜주고, 외부는 유지.)

# 데이터 지향

- 데이터를 데이터 그대로 사용하면, 여러가지 방법으로 해석할 수 있다는 장점이 있다.
- 제한된 API로 정의하면 데이터를 제대로 활용할 수 없다.
- 객체지향의 캡슐화를 완벽히 위배하는 원칙이다. 모든 패러다임에는 장단점이 있는 것 같다.
  - 캡슐화를 하면 데이터 구조를 바꾸기 더 쉬워진다. 하지만 제한된 API를 사용해야한다.
  - 캡슐화를 하지 않으면 데이터 구조를 바꾸기 더 어려워진다. 하지만 불필요한, 제한된 API를 정의할 필요도, 사용할 필요도 없다. 더 자유롭게 사용이 가능하다.

# 함수를 리턴하는 함수

- 함수를 리턴하는 함수를 사용하면, 리턴된 함수가 호출될 때 어떠한 동작을 자동으로 추가시켜 줄 수 있다.
- `withLogging` 함수를 즉시 실행 시키는게 아닌, 함수를 리턴하면 logging 로직이 적용된 함수를 받을 수 있다.
  - 느슨하게 결합시켜, 좀 더 쉽게 변경시킬 수 있다. `wrappLogging`이라는 함수를 사용해서 새로운 함수를 탄생시키고 해당 함수는 코드에서 사용된다. 해당 함수는 쉽게 변경될 수 있다.

# reduce

- reduce 함수의 초기값 규칙
  - 계산이 어떠한 값에서 시작되는가? (더하기 연산이라면 0, 곱셈 연산이라면 1)
  - 만약에 배열이 비어있다면, 어떠한 값을 리턴해야 하는가?
- reduce로 할 수 있는 것들
  - 실행 취소/복귀: 사용자 입력 리스트에 reduce를 적용한 것이 현재의 값, 취소는 리스트의 마지막 사용자 입력 없앰.

# 함수형 도구 체이닝

1. 단계에 이름 붙이기 (함수로 추출하기)
2. 콜백에 이름 붙이기 (함수로 추출하지 않고, 콜백만 추출하여 이름 붙이기)

   - 콜백을 추출하였을 때 좋은 점은, 콜백 함수를 재사용 할 수 있다는 것이다.
   - 코드의 추상화 수준이 높아진다.

3. 두 방법을 비교
   - 상황에 따라 더 좋은 방법을 선택하면 되지만, 대부분 2번째가 더 명확하다.
   - 두 방법 모두 함수의 단계가 중첩되는 것을 막는다는 공통점이 있지만, 2번째의 경우 재사용성이 더욱 높다.
   - filter, map 등의 함수는 우리가 이미 잘 인지하고 있는 함수이다. 함수의 의미를 파악하는게 더 쉽다.

# 스트림 결합

- map 함수를 여러번 체이닝하게 되면, 배열을 여러번 순회하게 된다. map 함수를 한번만 쓰면서, 필요한 로직을 내부에 전부 삽입해주는 것이다.
- 최적화이기 때문에 병목이 생겼을 때만 사용하는게 좋다. 여러 단계를 사용하는 것이 더 명확하고 읽기 쉽다.

# 다양한 함수형 도구

- pluck: 배열(순회 가능한 객체) 내 특정 필드값을 뽑아냄.
- concat,flatMap: 배열 평탄화 (1단계)
- frequenciesBy, groupBy: 개수를 세거나 그룹화 하는 일을 수행, 객체 또는 맵을 리턴함.

# 타임라인 다이어그램

- 시간에 따른 액션 순서를 시각적으로 표시한 것.
- 두 액션이 순서대로 나타나면 같은 타임라인에 넣는다.
- 두 액션이 동시에 실행되거나, 예상할 수 없다면 분리된 타임라인에 넣는다.
  - 비동기 작업은 분리된 타임라인에 넣어야한다. 콜백 함수의 시작 시점을 예측할 수 없으므로.
  - 분리된 타임라인의 경우, 왼쪽 혹은 오른쪽 어느 것이 먼저 끝날지 알 수 없다.
  - JS는 싱글 스레드로 완벽히 동시에 실행될 수 없다.

# 타임라인 개선 방법

- 타임라인의 수는 적을수록 이해하기 쉽다.
  - 분산 시스템을 많이 사용하는 현대적인 프로그래밍 구조상 사실상 힘듬.
- 타임라인 짧게 만들기. (박스 줄이기)
- 공유하는 자원을 적게 만들기
  - 서로 다른 타임라인에서 실행되는 액션이 자원을 공유하지 않는다면, 사실 누가 먼저 끝나던 상관이 없다.
- 자원을 공유한다면 서로 조율해야한다. (올바른 결과를 주지 않는 실행 순서를 없애버린다.)
- 시간을 일급으로 다룬다.

# 타임라인 단순화하기

- 하나의 타임라인에 있는 모든 액션을 하나로 통합한다.
  - js가 싱글스레드 이기 때문에 가능함.
- 타임라인이 끝나는 곳에서 새로운 타임라인이 하나 생긴다면 통합한다.
  - 어떠한 작업들이 콜백 형식으로 이어질 때, 사실 하나의 타임라인과 동일하다는 의미이다.
  - 하지만 2개 이상의 타임라인이 생긴다면 어떤 것이 먼저 끝날지 모르므로 통합할 수 없다.

# 분리된 타임라인으로 인한 오류 개선하기.

- 불필요한 공유 자원을 없앤다.

  - 전역 변수를 지역 변수로 바꾼다. 코드 실행 시점에 자원의 상태에 신경쓰지 않아도 된다.
  - 지역 변수로 바꾸면 함수 스코프 내에서 변화가 일어나기 때문에 외부 환경에 영향을 미치지 않는다. 즉 액션이 계산이 되므로 타임라인에서 지울 수 있다.

# 비동기 상황에서 함수의 리턴값

- 비동기 상황에서는 함수가 올바른 리턴값을 줄 수 없다. 따라서 리턴이 아닌, 콜백을 사용해야한다.
  - 백그라운드에 비동기 작업을 맡겨버리고, 함수의 호출은 끝나버리므로.
- 하지만 promise 객체를 사용하면, promise에 담아서 처리된 값을 리턴할 수 있다. js와 관련된 내용이라 저자가 뺀 것 같다.

# 큐를 동시성 기본형

- 동시성 기본형: 자원을 안전하게 공유할 수 있는 재사용 가능한 코드. (동시성 문제가 발생하지 않도록 도와주는 코드) 실행 가능한 순서를 제한하면서 동작한다.
- FIFO 이라는 큐의 구조를 이용하여, 비동기 작업을 순차적으로 만드는 코드. ex_timeline 참조.
- 비동기 작업이 끝나고, 콜백이 실행될 때 큐를 꺼내서 다음 작업을 실행시키는 원리를 가짐.
- 특정 개수 이상이 들어오면, 해당 작업을 하지 않는 DroppingQueue, 병렬적으로 비동기를 실행시키고 결과를 기다리는 Cut

# 반응형 아키텍쳐

- "X가 일어나면, Y,Z,A,B,C를 순서대로 처리해라" 를 다음과 같이 변경시킨다. "X가 일어나면, Y를 하고, Y가 일어나면 Z를 하고, Z가 일어나면 A를 하고.."
- 코드에 나타난 순차적 액션 순서를 뒤집는다. 효과와 효과에 대한 원인을 분리한다.
  - 장바구니를 변경시키면, 그에 따라 장바구니 icon이 변경되어야 한다고 할 때, 반응형 아키텍쳐가 아니라면 장바구니 추가, 삭제, 업데이트하는 모든 함수에서 icon과 관련된 로직을 처리해주어야 한다.
  - 원인이 5개이고, 효과가 4개일 때 반응형 아키텍쳐가 아니라면 우리는 `5*4=20`개의 코드를 관리해주어야 한다.
  - 반응형 아키텍쳐를 사용하면 `5+4`로 관리해주면 된다. 원인을 추가해도 효과를 관리해주지 않아도 되고, 효과를 추가해도 원인을 관리해주지 않아도 좋다.
- 여러 단계를 파이프라인으로 처리한다.
- 타임라인이 유연해진다. 타임라인이 유연해진다는 의미는 더 짧은 타임라인을 만들 수 있다는 것이다. (수직에서 수평으로 넓어짐.)
  - 수평으로 넓어진다는 것은 타임라인의 수가 많아지는 것 아닌가? -> 같이 공유하는 자원이 없기 때문에 타임라인이 많아져도 관계가 없다. (언제 끝나든 상관 없음.)

# 어니언 아키텍쳐

- 현실 세계와 상호작용하기 위한 서비스를 만드는 구조
- 규칙
  1. 현실 세계와 상호작용은 인터렉션 계층에서 한다.
  2. 계층에서 호출하는 방향은 중심방향이다.
  3. 계층은 외부에 어떤 계층이 있는지 모른다.
- 어니언 아키텍쳐는, 계층형 구조와 유사하다. 상위 계층이 변경이 용이하다. 그래서 인터렉션 계층의 변경이 더 쉽다.
- 도메인 계층은 인터렉션 규칙과 분리되어 최대한 계산으로 이루어져야한다. (cart에 대한 로직만 처리할 뿐, cart가 어디서 온건지는 상관하지 않는다.)
- 도메인은 도메인 용어로 이루어져야한다. (cart와 관련된 처리는 도메인 영역이지만, cart를 불러오는 ajax 요청은 도메인 영역이 아니다. 온라인 커머스라는 도메인에 ajax는 없다.)
