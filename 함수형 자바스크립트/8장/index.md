# 비동기 호출의 문제

- 함수 간에 일시적 의존 관계 형성

  - 일시적 결합은 어떤 함수를 논리적으로 묶어 실행할 때 발생. (어떤 함수가 실행될 때까지 기다리는 경우)
  - 의존하는 순간 참조 투명성 위배. 부수효과 발생.
  - 비동기에 의존하는 모든 코드 흐름을 의존 관계 때문에 콜백 이후로 넘겨야함.

- callback hell

  - 콜백은 값을 반환하는 대신, 제어의 역전을 수행한다.  
    (함수를 인자로 받는, 고계함수와는 다르다고 할 수 있다. 고계함수는 어떤 로직을 함수가 수행하는데, 로직에 필요한 함수를 인자로 받음. 그러나 callback은 함수 자체가 어떠한 로직도 가지지 않음. 제어를 외부에 위임함.)
  - 제어의 역전 구조는 함수형 프로그래밍 설계 사상과 정면으로 배치됨. (함수는 독립적이여야 하며, 값을 즉시 호출자에게 반환해야함.)

# 프라미스라는 모나드

- 비동기 작업을 값으로 다룬다. (일급)
- join 연산을 자동으로 수행한다. (promise 내에 promise가 존재하면 평탄화 작업을 수행한다.)
- 값을 변경하는데 인터페이스를 제공함으로써, 매끄러운 체이닝이 가능하다.
- 에러 관련 처리를 catch 메소드에 일임한다. 에러가 발생하면 then 체이닝을 멈추고 catch 블록으로 넘어가기에, 안전한 함수 합성이 가능하다.
- Promise 컨테이너에 구현된 static method는 비동기를 처리할 수 있는 로직을 제공한다. (Promise.all, Promise.race 등)

# 느긋한 데이터 생성.

- ES6의 강력한 특성은, 어떤 함수를 끝까지 실행하지 않아도 데이터 제공을 잠시 중단한 상태로 다른 함수들과 더불어 작동 시키는 능력(제너레이터 함수)
- 제너레이터 함수는 yield 키워드를 만나면 함수 밖으로 잠시 나갔다가, 자신의 보관된 컨텍스트를 찾아 다시 돌아오는 움직임을 보임.  
  따라서 흐름 체인으로 구성되어있는 함수가 있다고 가정할 때, 왼쪽에서 오른쪽으로 움직이는게 아니라, 세로로 반복하여 움직이는 것처럼 작동한다.  
  따라서 필요한 연산이 끝나면 yield 키워드는 더이상 값을 반환할 필요가 없어 매우 효율적이다.

# Rxjs

- 기존의 로대쉬와 같은 함수형 프로그래밍 라이브러리가 존재하여, 흐름 체인으로 소프트웨어를 구성할 수 있는데 rx.js는 왜 필요할까.
  - 함수형 프로그래밍을 적용할 수 있는 범위를 늘려준다.
  - observable이 발생하는 연속된 값들을 stream 이라고 하는데, 이 stream에는 **일반적인 값들 뿐만 아니라, 시간의 흐름, 사용자의 동작(이벤트), 비동기 작업까지 파이프라인에 흘려보내 처리한다는 것이다.**
