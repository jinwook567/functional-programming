# 생각 정리

- 이번 장은 악명높은 모나드에 대한 설명이 대부분이다. 모나드를 정확히 이해한지 모르겠지만 나의 생각을 정리해본다.
- 어플리케이션의 복잡성을 줄이기 위해서 모나드라는 안전한 합성 도구를 사용한다.
- 함수의 안전한 합성을 위해서 컨테이너에 값을 넣는다. 컨테이너에 넣는 이유는, 값을 다루고 변경하는 인터페이스를 통일하고 해당 로직 내부에서 어떠한 처리를 해줄 수 있기 떄문이 아닐까.
  그래서 쉽게 체이닝 또는 합성이 가능하고 규격화된 처리를 해줄 수 있도록.
- 모나드도 컨테이너이다. 다만 안전한 함수 합성을 위해 다형성을 지원하는 컨테이너라고 생각한다. 컨테이너로 감싸서 규격화된 인터페이스를 제공하고,  
  내부적으로 다형성을 지원함으로써 안전한 함수 합성을 하도록 한다.
  - 예시: 컨테이너를 클래스라고 가정하고, 내부 값을 변경시키는 메소드를 map 이라고 할 때, 값에 오류가 있어서 함수 합성을 하면 안될 경우에는 map 메소드에서 인자로 받은 함수를 호출하지 않고 흘린다.  
    값에 문제가 없다면 함수를 호출하고 값을 담은 새로운 컨테이너를 반환.

# try-catch

- 함수형은 if-else문과 같은 제어 로직을 추상화함. try-catch문과 같은 에러 처리도 추상화 필요가 있음.
- 에러 조건 처리하는 블록이 중첩.
- try-catch문을 사용하면 호출자의 부담이 가중하고, 다른 함수와 합성/체이닝 불가능.

# 왜 예외를 던지면 곤란한가?

- 참조 투명성 원리 위배. 에측 가능한 함수가 아님.
- 함수 호출 범위를 벗어나(catch 문으로 이동) 전체 시스템에 영향을 주는 부수효과 생길 수 있음. 비 지역성 원리 위배.
- 에러 처리 로직이 중첩되어 사용하기 어려움.
- 하지만, 예외를 아에 안던질 수는 없다. 적절히 사용하면 더 효율적인 경우도 있다. 또한 라이브러리에서 발생시키는 예외는 어쩔 수 없다.

# null check

- 예외로 처리하기 보다는, null을 던지면 함수를 흘러가게는 할 수 있다.  
   나도 방어적인 코드를 작성할 때 null check를 한 경험이 있다.
- 문제는 합성되는 모든 함수들에 null check를 해주어야 한다는 것이다.

# 컨테이너

- 컨테이너화는 함수형 프로그래밍의 기본 디자인 패턴이다.
- 값을 안전하게 다루기 위해 직접적인 접근을 차단. 왜 차단할까?
- 직접적인 접근을 차단한다는 것은, 어떤 규격화된 방식으로만 값을 변경할 수 있다는 것이고, 내부적으로 해당 방식에 어떠한 로직을 적용시켜줄 수 있다는 것이다.
- 동일한 인터페이스로 컨테이너를 다루어야 한다면, 컨테이너를 또 반환한다면 우리는 체이닝을 할 수 있다.

# 함수자

- 값을 래퍼 안으로 승급하고, 수정하고 다시 래퍼에 넣을 목적을 염두에 둔 함수 매핑이 가능한 자료구조.
- 부수효과가 없어야한다.
- 합성이 가능해야한다.

# 모나드

- 함수자가 건드리는 컨테이너가 모나드.
- 안전하게 함수를 합성하기 위해서 사용.
- **컨테이너 안으로 값을 승급하고 어떤 규칙을 정해 통제한다는 생각으로 자료형 생성.**
- 모나드: 모나드 연산을 추상한 인터페이스 제공
- 모나드형: 모나드 인터페이스를 구현한 형식

# 모나드가 준수해야하는 인터페이스

- 형식 생성자: 모나드 생성
- 단위 함수: 어떤 형식의 값을 모나드에 삽입(of 메소드)
- 바인드 함수: 연산을 서로 체이닝. 모나드를 리턴하여 체이닝 할 수 있도록.
- 조인 연산: 모나드를 평탄화. 모나드로 감싸진 값들을 합성할 때 모나드가 중첩된 구조로 생성되는데 이를 평탄화. 중첩된 모나드를 다루기는 매우 불편함.  
  (몇번 중첩 되었는지 호출자가 알아야하고..단순히 컨테이너를 벗기기 위해서 무의미한 함수들이 사용됨.)

# Maybe 모나드

- Maybe 모나드는 null 체크와 관련된 로직을 내부에서 처리해주어서 깔끔한 함수 합성이 가능하도록 한다.
- 만일 모나드 내부의 값이 null이라면 함수를 적용하지 않고 모나드 자체를 흘리는 식으로.
- 모나드가 적용되었다는 것을 알리기위해 변수명 앞에 safe를 붙여 구분한다.

# Either 모나드

- 2개의 컨테이너를 보유하고 활용하여 다형적으로 작동한다.
- Left에는 에러 메시지 또는 예외 객체를 담는다. Right에는 성공한 값을 담는다.
- 어떤 계산이 실패할 경우 원인에 관한 추가 정보를 결과와 함께 제공할 목적으로 쓰임.
- chain은 모나드형에 감싸지 않는데, 다른 모나드와 쉽게 합성하기 위해서이다.

# IO 모나드

- 부수효과가 일어나는 작업을 IO 모나드를 활용하여 다룬다.
- 순수 코드에서 불순 코드를 걷어내기 위해서. (액션과 계산을 분리)
- IO 연산이 불변한 것처럼 작동(IO 작업 함수를 값으로 담고 있다.). 시간과 순서에 따라서 다르게 작동하긴 하지만, 이 모나드 자체는 순수하다.
- IO 연산을 모나드화 하는 이유는 부수효과를 일으키는 함수의 실행 순서가 바뀌거나 호출 도중에 실행되는 일을 방지하게끔.
- 마지막에 존재하는 showStudent 예제에 IO 모나드를 적용한다. 그리고 해당 함수는 run 메소드를 작동시킴으로써 부수효과를 일으킨다. run 함수를 작동시키기 전까지는 평가되지 않아서 함수가 잘 담겨있다.
