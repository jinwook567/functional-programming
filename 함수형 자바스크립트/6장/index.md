# 함수형 프로그래밍이 왜 테스트하기 좋은가?

- 테스트의 시점, 순서, 횟수에 영향을 받지 않는다.
  - 순수한 함수들로 이루어졌기 때문. (독립적인 블랙박스 연산을 수행하고 이는 단위 테스트 철학과 동일하다.)
  - 테스트할 코드가 일으키는 부수효과를 찾아낼 필요가 없음.
- 통합 테스트를 최소화 할 수 있다.
  - 함수형 프로그래밍에서 가장 중요도가 높은 테스트는 단위 테스트이다.
  - 통합 테스트를 최소화 할 수 있는 이유는, 순수한 함수들의 합성으로 이루어졌고, 함수를 합성하는 함수는 어떠한 비즈니스 로직도 가지지 않는다. 따라서 합성하는 함수에 대한 테스트도 매우 간단하다.
  - 심지어 대부분 안전한 함수 합성을 위하여 라이브러리를 사용하고 해당 라이브러리는 이미 테스트까지 마쳐 안전함이 검증되어 있다.
- 필수적인 비즈니스 로직만 테스트 할 수 있다.
  - 분기, 순회와 같은 로직은 테스트 된 안전한 함수들에게 위임한다.
- 부수효과를 일으키는 함수의 경우 모킹을 하여 테스트를 수행한다.
  - 모킹을 통해서 테스트 전과 후 동일한 환경을 유지할 수 있다.
  - 외부 자원을 단언함으로써 더욱 예측 가능한 테스트를 할 수 있다.

# 단위 테스트의 장점

- 단위 테스트는 함수의 명세를 담고 문서화하는 용도로 쓸 수 있다.
- 물론 자연어를 통해서 함수의 명세를 담을 수 있으나, 해당 언어를 모를 수도 있고 맥락이 모호하게 변경될 수도 있다.  
  하지만 코드는 공용어이다.

# 테스트 coverage

- 명령형의 경우 코드의 제어 로직에 따른 모든 경우의 수를 테스트해야함. 따라서 높은 커버리지를 얻기 힘듬.
- 명령형으로 높은 테스트 커버리지를 얻으려면 그만큼 많은 테스트 케이스 작성해야함. 비용 소모 상승.

# 코드의 복잡도 측정

- 순환 복잡도: 함수의 선형 독립적인 경로의 개수를 측정하기 위한 소프트웨어 지표.
  - 노드: 더 이상 나눌 수 없는 코드 블록
  - 간선: 코드 블록이 흐름이 있을 때 이를 방향성 있는 간선으로 연결
  - 프로그램 복잡도 = (간선 개수) - (노드나 블록의 개수) + (출구 있는 노드의 개수)
  - 함수형은 매끄럽게 이어지는 흐름 체인을 구성하기 때문에 거의 순환 복잡도가 1로 수렴한다.
