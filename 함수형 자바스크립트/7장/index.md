# 함수형 프로그래밍 최적화 전략

- 함수의 개별 평가 속도를 높이기 보다는, 불필요한 함수 호출을 줄이는 형태로 개선함.

# 함수 실행 내부 작동 원리

- JS는 함수가 호출될 때마다 함수 context stack에 레코드가 생성됨.
- 빈 프레임은 48 바이트 정도, 지역,매개 변수는 약 8바이트 차지함.
- 스코프 체인은 함수의 컨텍스트를 부모의 실행 컨텍스트와 연결하거나 참조.
- 커링의 경우 함수 컨텍스트를 유지시키기 때문에 메모리 문제가 발생할 수 있다.
- 재귀의 경우에도, 기저 조건을 제대로 작성해주지 않거나, 거대한 자료구조를 처리할 때 stack overflow가 발생할 수 있다.

# 느긋한 평가

- 함수 호출이 필요할 때까지 평가를 미룬다.
- 느긋한 평가의 특징으로 range 메소드에 Infinity를 넣어도 상관없음. (최대 무한대 호출한다는 의미.)

# 단축 융합

- 몇 개의 함수의 실행을 하나로 병합, 중간 결과를 계산할 때 사용되는 내부 자료구조 개수 줄임.  
  자료구조를 줄임으로써 메모리 사용 낮춤.

# 메모화

- key, value 형태로 캐시를 저장하고 캐싱된 값이 존재할 경우 해당 값을 반환한다.
- 함수형 프로그래밍에서 메모화가 가능한 이유는 참조 투명성 때문이다. (어떤 인수를 넣었을 때 항상 동일한 값이 리턴됨을 보장.)
- 분해하여 메모화를 극대화한다. -> 더 많은 계산을 건너뛴다.

# 꼬리 재귀 호출 최적화

- 재귀는 매우 선언적으로 문제를 처리하지만, 많은 함수 컨텍스트를 생성한다는 단점이 존재한다.
- 재귀 함수가 제일 마지막에 재귀 함수를 호출할 경우에 꼬리 호출 제거가 일어난다. 재귀 호출 실행을 단일 프레임으로 눌러 편다.
  - 가장 마지막에 함수를 호출하면 자바스크립트 런타임은 더이상 할 일이 없으므로. 스택 프레임 폐기함.
- 거의 수동 루프와 맞먹을 정도로 성능을 끌어올린다.
