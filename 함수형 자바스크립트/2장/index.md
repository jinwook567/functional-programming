# 함수형 대 객체지향 프로그래밍

- JS는 하이브리드 언어. 함수가 일급으로 함수형 프로그래밍도 가능하며 프로토타입 기반으로 상속 등을 흉내낼 수 있어 객체지향 프로그래밍도 가능함.
- 두 패러다임을 적절히 사용하면 매우 효율적인 코드를 작성할 수 있음.
- 다형성을 예시로 들자면, 덕 타이핑이라는 특징을 이용하여 높은 함수의 다형성을 활용하여 재사용성을 늘리고,  
  만일 객체마다 다른 동작을 하는 함수가 여러개 존재한다면 객체 지향의 다형성 개념을 활용하여 코드를 작성해도 좋지 않을까.

## 객체지향

- 객체지향 프로그래밍의 경우 데이터(상태)와 기능(함수)가 객체 내부에 단단하게 응집된 형태.
- 객체지향에는 묻지말고 시켜라 라는 규약이 있음. 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안됨. 즉 객체의 상태를 전문가가 아닌 이에게 맡기면 안됨.
- 객체지향에서는 불변성을 지키지 않고 인스턴스의 상태를 바꿈. 따라서 만일 객체가 스스로 상태를 변화시키는게 아니고 외부에서 상태를 변화시킨다면, 상태 관리의 어려움이 증가
  (가변 상태의 무결성을 캡슐화에 의존)

## 함수형

- 객체와 함수를 느슨하게 결합.
- 메소드 형태가 아닌 외부 함수로 사용. JS는 덕 타이핑을 따르기 때문에 높은 수준의 다형성 지원. 즉 기반형을 인자로 받는 함수라면, 파생형도 이를 해당 함수의 인자로 들어갈 수 있음.
- 함수형에서는 this를 사용하는 것을 불순하다고 생각함. 스코프 밖에 있는 값을 사용하는 것이기 때문에.
- 객체를 불변하게 유지해야함. 객체를 값으로 취급함.

# 객체를 값으로 다루기(불변성 유지하기)

- 값 객체 패턴(클로저를 이용한 객체 리터럴 인터페이스를 반환하여 속성 변경을 불가능하도록 만듬.)
- 새로운 사본을 만들어서 제공. 객체가 중첩되어 있는 구조를 유의하여 제공해야함.
- Object.freeze를 이용하여 writable 메타속성을 false로 바꾸기. 이는 얕게 작용하므로, 객체가 중첩되어 있는 구조를 유의해야함.
- 객체 그래프를 렌즈로 탐색 및 수정.
  - 메소드에서 새로운 객체를 리턴해야할 때, 이 과정은 매우 따분하고 에러도 나기 십상. 판박이 코드 도배됨.
  - 람다js 라이브러리의 렌즈를 사용. 필드에 저근하는 로직을 객체로부터 분리하여 this 의존도 없앰. 중첩 속성까지 지원.

# FP에서 함수

- 사용 가능한 결과값을 낼 때만 유의미함. 그 외는 외부 데이터 변경 등 부수효과를 일으킨다고 봄.
- 책에서는 값을 내는 함수를 표현식, 값을 내지 않는 함수를 구문식으로 용어를 구분함.

# js에서 함수

- JS에서는 함수는 1급 시민임.
  - 변수나 데이터 구조에 담을 수 있음.
  - 파라미터로 전달할 수 있음.
  - 반환값으로 사용할 수 있음.

# 고계 함수

- 함수를 인수로 받거나 함수를 반환하는 함수
- 고계 함수를 쓰면 선언적 패턴이 늘어나기 시작해서, 코드의 추상화 수준이 높아지고 쉽게 이해할 수 있다.

# 스코프

## 전역 스코프

- 가장 삼가해야 할 스코프
- namespace 충돌 소지 높아짐.
- 전역 데이터는 데이터가 어떻게 변화해야 하는지 따라가야 하기 때문에 복잡한 프로그램을 만드는 부작용 초래함.

## 함수 스코프

- 함수가 반환되는 시점에 사라짐. 외부에서 접근 불가.

# 클로저

- 프라이빗 변수 모방
  - ex: 모듈 패턴
- 서버 측 비동기 호출
  - 콜백
- 가상의 블록 스코프 변수 생성
  - for와 let을 활용한 루프보다는 forEach문. 굉장히 안전한 함수 스코프가 만들어진다.
  - 자동으로 루프를 돌며 접근하는 개별적 원소(클로저)에 접근하는 함수.
- 개인적으로 가장 효과적으로 쓰이는 클로저는 인자가 고정된 함수를 배출하는 커링같다. 또한 인자를 기억한다는 점에서 클로저를 가장 잘 나타낸다고 생각한다.
