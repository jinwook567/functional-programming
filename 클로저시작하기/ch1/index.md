# 자기 자신으로 평가되는 식

- 단순값 혹은 리터럴이라고 부른다.
- 분수의 경우 자연수와 자연수로 나눈다면, 실수로 변환되지 않아 잘림 현상이 없다.
- 문자열은 큰 따옴표를 감싸써 만든다.
- 키워드는 :(콜론)으로 시작하는 식별자이다. 키워드 역시 단순값이다.
- 문자열이 아닌 하나의 문자만을 원한다면, 문자 앞에 역슬래쉬를 붙인다. 부하가 줄어든다.
- boolean, nil도 자기 자신으로 평가된다.

# 클로저 데이터를 컬렉션에 담기

- 클로저가 가지고 있는 컬렉션은 리스트(list), 벡터(vector), 맵(map), 집합(set)이다.
- 컬렉션은 불변이고 존속적이다.
  - 예시로 `(cons 5 '(1 2))`를 출력하면 리스트 (1, 2)는 변함이 없다. 5가 추가된 (5, 1, 2)라는 새로운 리스트가 반환된다.
  - 불변이란 컬렉션의 값이 변경되지 않는다는 의미이다.
  - 존속적이란, 구조 공유를 사용하여 새로운 컬렉션을 효율적으로 만든다.

## 리스트

### 리스트를 만드는 방법

- 인용 기호(')를 괄호 앞에 붙이고 데이터를 괄호안에 넣는다. `'(1 2 3 4 5)`
- list 함수를 사용한다. `(list 1 2 3 4 5)`
- 요소들 사이에 쉼표가 있어도 되고, 없어도 된다. 쉼표를 사용하지 않는 것이 관용적이다.
- 문자열, 정수, 키워드 등 여러 종류의 값을 컬렉션 안에 혼합해도 상관없다.

### 리스트 다루기

- 리스트는 2가지 부분으로 구성되어 있다. 리스트의 첫 요소, 리스트의 나머지 요소
- first 함수는 리스트의 첫 요소를 반환하고, rest는 리스트의 나머지 요소를 반환한다.
- rest를 계속 사용해서 리스트의 마지막에 다다르면 nil을 만나게 된다.
- 리스트에 요소를 추가하고 싶다면, cons 함수를 이용한다.
  - cons 함수는 2개의 인자를 받는데 첫 번째는 추가할 요소, 두 번쨰는 리스트이다.
  - nil은 리스트의 끝을 의미한다. `(cons 5 nil)`도 동작한다. 빈 리스트에 5개 삽입된다.

## 벡터

### 벡터를 만드는 방법

- 대괄호로 둘러싸서 만든다. `[1 2 3 4 5]`

### 벡터를 다루는 방법

- 리스트와 동일하게 first, rest가 동작한다.
- nth 함수는 해당 인덱스에 있는 벡터의 요소에 접근할 수 있다. `(nth '(1,2,3) 0)`
- last 함수는 벡터의 마지막 요소를 반환한다.
- 리스트도 nth, last 함수를 사용할 수 있으나, 벡터의 성능이 더 좋다. 리스트의 경우 순회하면서 인덱스를 찾기 때문이다. 벡터는 바로 요소에 접근한다.
- count 함수는 컬렉션의 크기를 반환한다.

## 컬렉션을 다루는 함수

- count 함수는 컬렉션의 크기를 반환한다.
- conj 함수는 컬렉션의 하나 이상의 요소를 추가한다.
  - 다만 컬렉션의 데이터 구조에 가장 효율적인 방식으로 추가한다.
  - 리스트의 경우, 리스트의 맨 앞에 추가되며 벡터의 경우 맨 뒤에 요소가 추가된다.

## 맵

- 키-값 쌍으로 된 컬렉션

### 맵을 만드는 방법

- `{ :jam "strawberry" :jam2 "blueberry" }`

### 맵을 다루는 방법

- get 함수를 활용하여 맵에서 값을 가져올 수 있다. `(get { :jam "strawberry" :jam2 "blueberry" } :jam)`
- 만약 맵의 키가 키워드라면 get을 사용하지 않고, 키 자체를 함수로 사용할 수 있다. `(:jam { :jam "strawberry" :jam2 "blueberry" })`
  - 키를 함수로 사용하는 것이 더 관용적이다.
- keys 함수는 맵의 키만을, vals 함수는 맵의 값만을 반환한다.
- assoc 함수는 맵에 새로운 키-값 쌍을 결합한다.
  - `(assoc { :jam "strawberry" :jam2 "blueberry" } :jam "lemon")`
- dissoc 함수는 맵과 키를 인수로 받아 키-값 쌍이 제거된 새로운 맵을 반환한다.
  - `(dissoc { :jam "strawberry" :jam2 "blueberry" } :jam)`
- merge 함수는 여러개의 맵을 인자로 받으며, 맵을 합쳐준다.
  - `(merge {:jam1 "orange} {:jam2 "lemon"} {:jam3 "grape"})`

## 집합(Set)

### 집합을 만드는 방법

- `#{}` 안에 요소를 삽입한다.
- `set` 함수를 사용하여 다른 종류의 컬렉션을 집합으로 변경할 수 있다. set 함수를 활용하여 중복된 값을 제거할 수 있다.

### 집합을 다루는 방법

- 집합이기 때문에 합집합, 차집합, 교집합과 같은 집합 연산이 가능하다.
  - clojure.set/union 함수는 모든 집합의 요소를 합친다.
  - clojure.set/difference 함수는 차집합을 반환한다.
  - clojure.set/intersection 함수는 교집합을 반환한다.
- 값을 가져오기 위해서는 `get` 함수를 사용하면 된다.
- 키워드 자체를 함수로 사용하여 값을 가져올 수 있다.
- 집합 자체를 함수로 사용하고, 인자를 받아서 값을 가져올 수 있다.
- 집합에 요소가 있는지 확인할 수 있는 contains? 함수가 있다.
- conj 함수를 사용하여 요소를 추가한다.
- disj 함수를 사용하여 요소를 삭제한다.

# 심볼과 바인딩의 기술

- 클로저 심볼은 값을 가르킨다. 심볼이 평가되면 심볼이 가리키는 값을 반환한다.
- `def`는 값에 이름을 주어서 해당 값을 참조할 수 있도록 한다. 참조된 값은 불변하다.
  - 선언된 이름 공간에 var 객체가 생성된다.

## let

- 전역적인 var를 만들고 싶지 않을 때, 임시의 var를 만들고 싶은 경우 사용된다.
- let을 사용하면 let 영역 안에서만 사용되는 심볼에 값을 바인딩 할 수 있다.
- let의 바인딩은 벡터 안에 심볼과 값의 쌍들로 구성된다.

# 함수

- defn은 함수 이름, 함수 인수들의 벡터, 함수 본문을 인수로 받는다.
  - `(defn follow [] "off we go")`
- 무명 함수는 fn을 활용하여 만들 수 있다. 함수 인수들의 벡터와 함수 본문을 인수로 받는다.
- 무명 함수의 단축형은 괄호 앞에 #를 붙인다. 인수가 하나라면 %, 여러개라면 %1, %2 이렇게 나타낸다.
  - (#(str "off we go" "!" %1 %2))

# 이름 공간

- 이름 공간은 var에 대한 접근을 조직하고 제어하는 방법이다.
- ns를 사용하면 이름 공간을 생성하고 해당 이름 공간으로 전환할 수 있다.
- `*ns*`를 사용하면 이름 공간을 볼 수 있다. 별표를 귀마개라고 부르는데, 다시 바인딩 할 수 있는 것을 표시하는 관례이다.
- 다른 이름 공간에 같은 이름으로 var를 생성할 수 있다.

## require

- 클로저 라이브러리는 이름공간과 해당 이름공간의 심볼로 구성된다.
- 클로저 라이브러리를 사용하는 방법은 3가지이다.
  - require를 사용하고 이름 공간을 인수로 받는다. `(require 'clojure.set)`
  - :as를 사용하여 require의 별칭 기능을 활용한다. `(require '[alice.favfoods :as af])`
    - require를 직접 사용할 수 있지만, 보통 ns 안에서 키워드와 벡터 형태로 사용된다. 이 방법을 사용하는 것이 클로저의 관행이다.
  - :refer, :all 옵션을 사용하여 이름 공간의 모든 심볼을 로딩한다. 이름 충돌이 발생할 가능성이 있다.
